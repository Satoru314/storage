# ファイルストレージサーバー 詳細設計書

## 1. システム概要

**目的**: 画像ファイルの安全で効率的なアップロード・管理システムの構築

**システム構成**:
- **フロントエンド**: SPA (Single Page Application)
- **アプリケーションサーバー**: RESTful API サーバー
- **データベース**: RDB (メタデータ管理)
- **ファイルストレージ**: オブジェクトストレージ (S3等)
- **認証**: クラウドプロバイダー認証

---

## 2. アーキテクチャ設計

```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   Frontend      │    │   API Server    │    │ Object Storage  │
│     (SPA)       │◄──►│  (RESTful API)  │◄──►│   (S3 etc.)     │
└─────────────────┘    └─────────────────┘    └─────────────────┘
                                │
                                ▼
                        ┌─────────────────┐
                        │   Database      │
                        │  (Metadata)     │
                        └─────────────────┘
```

### 2.1 アーキテクチャ選択の背景

**直接アップロード方式の採用**:
- **課題**: 大容量ファイルのアップロードによるサーバー負荷
- **解決策**: フロントエンドからオブジェクトストレージへの直接アップロード
- **メリット**: サーバー負荷軽減、スケーラビリティ向上、転送速度最適化

**責務の分離**:
- **フロントエンド**: UI/UX、ファイル選択、アップロード実行
- **APIサーバー**: メタデータ管理、権限制御、ビジネスロジック
- **データベース**: 構造化データ（ファイルメタ情報）の永続化
- **オブジェクトストレージ**: 非構造化データ（ファイル本体）の保存

### 2.2 データフロー設計

1. **アップロード要求**: フロントエンド → APIサーバー（ファイル情報）
2. **メタデータ保存**: APIサーバー → データベース（事前登録）
3. **署名付きURL生成**: APIサーバー → オブジェクトストレージAPI
4. **直接アップロード**: フロントエンド → オブジェクトストレージ
5. **完了通知**: フロントエンド → APIサーバー（ステータス更新）

---

## 3. API設計

### 3.1 エンドポイント一覧

| Method | Endpoint | 説明 |
|--------|----------|------|
| POST | `/images/upload-request` | アップロード用presigned URL取得 |
| POST | `/images/upload-complete` | アップロード完了通知 |
| GET | `/images` | 画像一覧取得 |
| GET | `/images/:id` | 画像詳細取得 |
| POST | `/images/view-urls` | 表示用presigned URL取得 |
| GET | `/healthz` | ヘルスチェック |

### 3.2 API詳細

**POST /images/upload-request**
```json
// Request
{
  "fileName": "example.jpg",
  "contentType": "image/jpeg",
  "fileSize": 1024000
}

// Response
{
  "image": {
    "id": "uuid",
    "objectKey": "y=2024/m=08/d=24/uuid_example.jpg",
    "originalName": "example.jpg",
    "mimeType": "image/jpeg",
    "byteSize": 1024000,
    "status": "requested"
  },
  "upload": {
    "method": "PUT",
    "url": "https://presigned-url...",
    "headers": {
      "Content-Type": "image/jpeg"
    },
    "expiresInSec": 300
  }
}
```

**POST /images/upload-complete**
```json
// Request
{
  "id": "uuid",
  "objectKey": "y=2024/m=08/d=24/uuid_example.jpg"
}

// Response
{
  "status": "ok"
}
```

---

## 4. フロントエンド設計

### 4.1 コンポーネント構成
```
App.tsx
├── Layout.tsx
├── Upload.tsx        // アップロード機能
└── ImageList.tsx     // 画像一覧表示
```

### 4.2 アップロードフロー

**イベントハンドリング**:
```typescript
const handleFileUpload = async (file: File) => {
  try {
    // 1. アップロード要求
    const uploadRequest = await requestUpload({
      fileName: file.name,
      contentType: file.type,
      fileSize: file.size
    });

    // 2. S3に直接アップロード
    await uploadToS3(uploadRequest.upload.url, file, {
      headers: uploadRequest.upload.headers
    });

    // 3. アップロード完了通知
    await notifyUploadComplete({
      id: uploadRequest.image.id,
      objectKey: uploadRequest.image.objectKey
    });

    // 4. UIを更新
    setUploadStatus('success');
    refreshImageList();
  } catch (error) {
    setUploadStatus('error');
    console.error('Upload failed:', error);
  }
};
```

### 4.3 状態管理
```typescript
interface UploadState {
  status: 'idle' | 'uploading' | 'success' | 'error';
  progress: number;
  error: string | null;
}

interface ImageState {
  images: ImageMeta[];
  imageUrls: Map<string, string>;
  loading: boolean;
  error: string | null;
}
```

---

## 5. データベース設計

### 5.1 imagesテーブル
```sql
CREATE TABLE images (
    id UUID PRIMARY KEY,
    object_key VARCHAR(512) UNIQUE NOT NULL,
    original_name VARCHAR(255) NOT NULL,
    mime_type VARCHAR(100) NOT NULL,
    byte_size BIGINT NOT NULL,
    width INTEGER,
    height INTEGER,
    e_tag VARCHAR(255),
    storage_status VARCHAR(20) NOT NULL 
        CHECK (storage_status IN ('requested','uploaded','failed','deleted')),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    uploaded_at TIMESTAMP WITH TIME ZONE
);

-- インデックス
CREATE INDEX idx_images_object_key ON images(object_key);
CREATE INDEX idx_images_status ON images(storage_status);
CREATE INDEX idx_images_created_at ON images(created_at DESC);
```

---

## 6. セキュリティ考慮事項

### 6.1 ファイル検証
- **MIMEタイプ検証**: 許可された画像形式のみ
- **ファイルサイズ制限**: 最大50MB
- **ファイル名サニタイズ**: 安全なオブジェクトキー生成

### 6.2 アクセス制御
- **Presigned URL**: 限定的な時間でのアクセス (5分)
- **CORS設定**: 許可されたオリジンからのみアクセス
- **認証情報**: 環境変数での管理

### 6.3 S3設定
```json
{
  "cors": [{
    "allowedOrigins": ["http://localhost:5173"],
    "allowedMethods": ["GET", "PUT"],
    "allowedHeaders": ["*"],
    "maxAgeSeconds": 3000
  }]
}
```

---

## 7. パフォーマンス考慮事項

### 7.1 アップロード最適化
- **直接アップロード**: S3へ直接アップロードし、サーバー負荷軽減
- **Presigned URL**: 一時的なアクセス権限で安全性確保
- **並列処理**: 複数ファイルの並列アップロード対応

### 7.2 表示最適化
- **遅延ロード**: 画像URL取得の遅延実行
- **サムネイル表示**: 適切なサイズでの表示
- **キャッシュ戦略**: Presigned URLの適切な有効期限設定

---

## 8. 設計の妥当性評価

### 8.1 代替案との比較

**従来方式（サーバー経由アップロード）**:
- メリット: シンプルな実装、一元的な制御
- デメリット: サーバー負荷、帯域制限、スケール困難

**提案方式（直接アップロード）**:
- メリット: 高い可用性、スケーラビリティ、コスト効率
- デメリット: 実装複雑性、クライアント側処理増加

### 8.2 非機能要件への対応

**可用性**: 
- オブジェクトストレージの99.999%可用性活用
- APIサーバーのステートレス設計によるスケールアウト対応

**パフォーマンス**:
- 直接アップロードによる転送速度最適化
- CDN活用可能な設計（将来拡張）

**セキュリティ**:
- 署名付きURLによる時間制限アクセス
- 事前検証によるファイル種別・サイズ制限